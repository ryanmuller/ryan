

How I make [[software]]

## Languages

Using a bastardization of [[http://michaelochurch.wordpress.com/2013/04/22/gervais-macleod-23-the-shodan-programmer/|Michael O. Church's ranking system]] (his are meant to be applied to the programmer holistically). These may be out-of-date, so please don't use for hiring! Ordered by current level of interest.

**[[Haskell]]** (0.5)

**[[Ruby]]** (1.5)

**[[Clojure]]** (0)

**[[JavaScript]]** (1.2)

**[[MATLAB]]** (0.3)

**[[OCaml]]** (0.1)

**[[Python]]** (1.2) strong scientific computing and data analysis community

**[[Scheme]]** (0.5)

**[[Scala]]** (0) 

**[[Lua]]** (0) lightweight embeddable scripting language; [[http://torch.ch/|Torch]]

**[[Erlang]]** (0) "truly concurrent programming"

**[[Java]]** (0.9)

**[[C++]]** (0.9)

## Topic

[[Machine learning]]

[[Algorithms]] 

[[Monte carlo method]]

[[Video game development]]

[[Competitive programming]]

## Learning

//The Little LISPer// and its descendants use a quick question-answer format that encourages [[feedback]] and [[comparison]].

Drills suggested by Steve Yegge:

<blockquote>Write your resume. List all your relevant skills, then note the ones that will still be needed in 100 years. Give yourself a 1-10 rating in each skill.

Make a list of programmers who you admire. Try to include some you work with, since you’ll be borrowing them for some drills. Make one or two notes about things they seem to do well — things you wish you were better at.

Go to Wikipedia’s entry for computer science, scroll down to the “Prominent pioneers in computer science” section, pick a person from the list, and read about them. Follow any links from there that you think look interesting.

Read through someone else’s code for 20 minutes. For this drill, alternate between reading great code and reading bad code; they’re both instructive. If you’re not sure of the difference, ask a programmer you respect to show you examples of each. Show the code you read to someone else, and see what they think of it.

Make a list of your 10 favorite programming tools: the ones you feel you use the most, the ones you almost couldn’t live without. Spend an hour reading the docs for one of the tools in your list, chosen at random. In that hour, try learn some new feature of the tool that you weren’t aware of, or figure out some new way to use the tool.

Pick something you’re good at that has nothing to do with programming. Think about how the professionals or great masters of that discipline do their practice. What can you learn from them that you can apply to programming?

Get a pile of resumes and a group of reviewers together in a room for an hour. Make sure each resume is looked at by at least 3 reviewers, who write their initials and a score (1-3). Discuss any resumes that had a wide discrepancy in scoring.

Listen in on a technical phone screen. Write up your feedback afterwards, cast your vote, and then talk about the screen with the screener to see if you both reached the same conclusions.

Conduct a technical interview with a candidate who’s an expert in some field you don’t know much about. Ask them to explain it to you from the ground up, assuming no prior knowledge of that field. Try hard to follow what they’re saying, and ask questions as necessary.

Get yourself invited to someone else’s technical interview. Listen and learn. Try to solve the interview questions in your head while the candidate works on them.

Find a buddy for trading practice questions. Ask each other programming questions, alternating weeks. Spend 10 or 15 minutes working on the problem, and 10 or 15 minutes discussing it (finished or not.)

When you hear any interview coding question that you haven’t solved yourself, go back to your desk and mail the question to yourself as a reminder. Solve it sometime that week, using your favorite programming language.
</blockquote>
